<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Blog kỹ thuật máy tính]]></title>
  <link href="http://ktmt.github.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://ktmt.github.com/"/>
  <updated>2013-05-13T07:51:45+09:00</updated>
  <id>http://ktmt.github.com/</id>
  <author>
    <name><![CDATA[kỹ thuật máy tính]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Memoization and Decorator]]></title>
    <link href="http://ktmt.github.com/blog/2013/05/06/memoization-and-decorator/"/>
    <updated>2013-05-06T16:44:00+09:00</updated>
    <id>http://ktmt.github.com/blog/2013/05/06/memoization-and-decorator</id>
    <content type="html"><![CDATA[<h2>What is memoization</h2>

<p>Trước hết chúng ta làm quen với khái niệm memoization. Ngôn ngữ ở đây là Python, bài toán là viết hàm tính giai thừa (n!)</p>

<p>Hàm giai thừa thông thường sẽ được viết đệ quy như sau:
{% codeblock  python.py %}
def fac(n):</p>

<pre><code>if n &lt; 2: return 1
return n * fac(n - 1)
</code></pre>

<p>{% endcodeblock %}</p>

<p>Có gì không ổn ở đoạn code này ? Cách giải quyết hoàn toàn không có vấn đề, nhưng nếu tinh ý bạn sẽ nhận thấy có 1 khối lượng tính toán bị lặp lại khá nhiều khi chạy nhiều hàm fac(n). VD, nếu tính fac(3), fac(4) và fac(10) lần lượt sẽ đòi hỏi 3 flow tính toán riêng rẽ mà không có reuse: fac(3) sẽ tính đệ quy từ fac(2) xuống fac(1), fac(4) tính đệ quy từ fac(3) xuống fac(1) và fac(10) tính đệ quy từ fac(9) xuống fac(1) !</p>

<p>Áp dụng memoization dưới dạng dict, ta có thể viết hàm fac_m như sau:</p>

<p>{% codeblock  python.py %}
memo = {}
def fac_m(n):</p>

<pre><code>if n&lt;2: return 1
if n not in memo:
    memo[n] = n * fac_m(n-1)
return memo[n]
</code></pre>

<p>{% endcodeblock %}</p>

<p>Ở đây memo đóng vài trò như 1 cache. fac(3) sẽ generate ra 3 record in cache, và fac(4) sẽ hit cache khi chạy đệ quy được 1 lần. Tương tự fac(10) sẽ hit cache khi đệ quy xuống đến fac(4)</p>

<p>Như vậy memoization đơn giản chỉ là tìm cách nhớ những phần tử để giảm khối lượng tính toán</p>

<p>Memoization có thể implement dưới dạng function...</p>

<p>{% codeblock  python.py %}
def memoize(fn, arg):</p>

<pre><code>memo = {}
if arg not in memo:
    memo[arg] = fn(arg)
return memo[arg]
</code></pre>

<p>def fac_m_f(n):</p>

<pre><code>return memoize(fac,n)
</code></pre>

<p>{% endcodeblock %}</p>

<p>...hoặc class</p>

<p>{% codeblock  python.py %}
class Memoize:</p>

<pre><code>def __init__(self, f):
    self.f = f
    self.memo = {}
def __call__(self, *args):
    if not args in self.memo:
        self.memo[args] = self.f(*args)
    return self.memo[args]
</code></pre>

<p>fac= Memoize(fac)
{% endcodeblock %}</p>

<p>Thêm 1 step nữa, thay vì "fac=Memoize(fac)" như ở trên, bạn có thể viết hàm mới theo kiểu decorator</p>

<p>{% codeblock  python.py %}
@Memoize
def fac_m_d(n):</p>

<pre><code>if n&lt;2: return 1
return n * fac_m_d(n-1)
</code></pre>

<p>{% endcodeblock %}</p>

<p>Decorator ở đây là từ khoá "@Memoize" trước định nghĩa của hàm fac_m_d</p>

<p>Vậy decorator trong Python là gì và cách dùng ra sao ?</p>

<h2>Python decorator</h2>

<p>Trong số các design pattern, có 1 design pattern gọi là "decorator design pattern". Python decorator chỉ là 1 cách implement của decorator design pattern. 2 khái niệm này không hoàn toàn giống nhau. Một điểm nữa cần nhớ là, memoization ở trên chỉ là 1 trong các ứng dụng của python decorator, python decorator còn có nhiều ứng dựng khác.</p>

<p>Mọi function trong python đều là object, cho phép ta có thể assign funtion cho variable hoặc defince function trong chính 1 function khác. Dựa vào đó, decorator có thể dưới dạng decorator function như ví dụ dưới đây:</p>

<p>{% codeblock  python.py %}
def gotham(f):</p>

<pre><code>def inside_gotham():
    print "Gotham needs Batman"
    f()
return inside_gotham
</code></pre>

<p>@gotham
def batman():</p>

<pre><code>print "Batman Here! Gotham is saved! " 
</code></pre>

<p>batman()
{% endcodeblock %}</p>

<p>Đoạn code sẽ cho output:</p>

<p>{% codeblock %}
Gotham needs Batman
Batman Here! Gotham is saved!
{% endcodeblock %}</p>

<p>Cơ chế của decorator có thể hiểu đơn giản là, khi compiler đọc đến đoạn code đefine function với decorator, compiler sẽ compile function 1 cách bình thường và pass function object kết quả thẳng cho decorator(dưới dạng function hoặc class). Decorator(function hoăc class) lấy agrument là 1 function object và return kết quả là 1 function object khác.</p>

<p>Function object kết quả nói trên gồm function object ban đầu đã được gói lại và "thêm thắt", và từ nay về sau sẽ được gọi thay cho function object ban đầu mỗi khi có lệnh call.</p>

<p>Ngoài memoization bên trên, bạn có thể dễ thấy rất nhiều ứng dụng của decorator trong các task liên quan đến wrap VD như:</p>

<p>Timing, benchmark tính toán thời gian run code</p>

<p>{% codeblock  python.py %}
def time_cal(func):</p>

<pre><code>def wrapper(*arg):
    t = time.time()
    res = func(*arg)
    print func.func_name, time.time()-t
    return res
return wrapper
</code></pre>

<p>@time_cal
def fac(n):</p>

<pre><code>if n &lt; 2: return 1
return n * fac(n - 1)
</code></pre>

<p>{% endcodeblock %}</p>

<p>hay trong web application, nếu bạn đã dùng Flaskr, bạn có thể thấy đoạn code sau</p>

<p>{% codeblock  python.py %}
@mod.route('/me/')
@requires_login
def home():
...
{% endcodeblock %}</p>

<p>Ở đây trang web của bạn ở sublink ".../me" sẽ được đảm bảo chỉ viewable với user đã login. Decorator "@requires_login" có thể viết ở 1 file độc lập và mọi hàm cần tính đảm bảo như trên chỉ cần thêm "@requires_login" đằng trước.</p>

<p>{% codeblock  python.py %}
from functools import wraps
...
def requires_login(f):</p>

<pre><code>@wraps(f)
def decorated_function(*args, **kwargs):
    if g.user is None:
        flash(u'You need to be signed in for this page.')
        return redirect(url_for('users.login', next=request.path))
    return f(*args, **kwargs)
return decorated_function
</code></pre>

<p>{% endcodeblock %}</p>

<h2>Kết luận</h2>

<ul>
<li>Memoization: pattern dùng để nhớ các tính toán nhằm làm giảm workload khi gặp các bài toán đệ quy</li>
<li>Decorator pattern: decorator design pattern</li>
<li>Python Decorator: Python tools để implement decorator pattern</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python object model]]></title>
    <link href="http://ktmt.github.com/blog/2013/04/29/python-object-model/"/>
    <updated>2013-04-29T00:00:00+09:00</updated>
    <id>http://ktmt.github.com/blog/2013/04/29/python-object-model</id>
    <content type="html"><![CDATA[<h3>1. old-style và new-style class trong Python</h3>

<p>Bạn đã nghe ở đâu đó "In python everything is object".</p>

<p>Điều đó có nghĩa là gì? Liệu nó có giống các ngôn ngữ lập trình khác,
mọi thứ trong Python đều là instance của BaseClass? Tôi đã nghe về <strong>object</strong>
class trong Python, liệu đó có phải là Base Class của Python</p>

<p>Python có hai mô hình <strong>old-style</strong> và <strong>new-style</strong>. Thực tế trong các phiên bản cũ của Python, không có một class cụ thể nào cho mọi object cả. Nhưng từ Python 2.2, với sự giới thiệu của <strong>new-style</strong> class, chúng ta có thể biến mọi object là instance của <strong>object</strong></p>

<p>Từ Python 2.1 trở về trước, <strong>old-style</strong> class là lựa chọn duy nhất cho các lập trình viên. Khái niệm <strong>old-style</strong> class là không liên quan tới khái niệm kiểu. Nếu x là một instance của old-style class, x.<strong>class</strong> sẽ trỏ tới class của x, nhưng type(x) thì không.</p>

<p>{% codeblock python.py %}</p>

<h1>old-style class was define by statement:</h1>

<h1>class <class-name>: <class definition body></h1>

<blockquote><blockquote><blockquote><p>class A:</p>

<pre><code>    pass
</code></pre>

<h1>type of class A is 'type' because 'type' is base-class in Python</h1>

<p>type(A)
<type 'type'></p></blockquote></blockquote></blockquote>

<h1>make an instance of A</h1>

<blockquote><blockquote><blockquote><p>a = A()</p>

<h1>a.<strong>class</strong> reference to class A</h1>

<p>a.<strong>class</strong>
<class __main__.A at 0x10aea6ce8></p>

<h1>bute type of a is not A but 'instance'</h1>

<p>type(a)
<type 'instance'></p>

<h1>'instance' still is 'type' class</h1>

<p>type(type(a))
<type 'type'>
{% endcodeblock %}</p></blockquote></blockquote></blockquote>

<p><strong>new-style</strong> class được giới thiệu với động lực tạo ra một mô hình object thống nhất cho Python. Mọi đối tượng sẽ được kế thừa từ <strong>object</strong></p>

<p>{% codeblock python.py %}</p>

<blockquote><blockquote><blockquote><p>object.<strong>class</strong>
<type 'type'>
type(object)
<type 'type'>
{% endcodeblock %}</p></blockquote></blockquote></blockquote>

<p><strong>new-style</strong> class được định nghĩa bằng cách kế thừa từ <strong>object</strong> class.
Khác với <strong>old-style</strong> class, nếu x là một instance của <strong>new-style</strong> class, cả x.<strong>class</strong> và type(x) đều trỏ về class của x</p>

<p>{% codeblock python.py %}</p>

<blockquote><blockquote><blockquote><p>class A(object): pass
A.<strong>class</strong>
<type 'type'>
x = A()
x.<strong>class</strong>
type(x)
<type 'A'>
{% endcodeblock %}</p></blockquote></blockquote></blockquote>

<p>Để tương thích với các phiên bản của của Python, class mặc định vẫn được để ở <strong>old-style</strong>.
Nếu chúng ta muốn sử dụng <strong>new-style</strong>, chúng ta bắt buộc phải định nghĩa class là subclass của <strong>object</strong></p>

<h3>2. Điểm khác biệt giữa <strong>old-style</strong> và <strong>new-style</strong> class</h3>

<p>Điểm khác biệt rõ nhất được nhìn thấy trong hệ thống kiểu.
Hãy xem làm thế nào <strong>old-style</strong> class và <strong>new-style</strong> class thực hiện việc đa kế thừa. "Đa kế thừa" là khả năng một class có thể kế thừa từ nhiều class khác nhau. Nếu A kế thừa từ B, A là subclass(child class, derived class) của B, còn B là superclass (base class, parent class của A)</p>

<p>Đa kế thừa cho phép một class A có thể có nhiều cha (theo tôi, đa kế thừa không thực sự tốt. có nhiều cách để giải quyết vấn đề đa kế thừa, hãy xem Ruby với mixins hay Java với interface thực hiện điều đó. tôi thực sự rất thích mô hình mixins của Ruby)</p>

<p>Trong mô hình object của Python, mọi class đều có thuộc tình <strong><strong>bases</strong></strong> để lưu lại tất cả các class cha của nó, theo thứ tự xuất hiện của việc thừa kế.</p>

<p>{% codeblock python.py %}</p>

<blockquote><blockquote><blockquote><p>class A: pass
class B: pass
class C(A, B): pass
C.<strong>bases</strong>
(<class __main__.A at 0x10aea6ce8>, <class __main__.B at 0x10af8de20>)
{% endcodeblock %}</p></blockquote></blockquote></blockquote>

<p>Vấn đề của đa kế thừa đó là thự tự của các superclass.</p>

<p>Khi một instance của một subclass truy cập vào một thuộc tính (hoặc một method),</p>

<pre><code>đầu tiên, nó sẽ tìm kiếm các thuộc tính được định nghĩa trong không gian của nó.
Nếu thuộc tình (hoặc method) không được tìm thấy, nó sẽ tìm đến không gian
của class (thuộc tính của class, hàm của class). Nếu vẫn không tìm thấy, nó
sẽ tìm kiếm tiếp trong không gian của các super class. Khi một class có nhiều
super class, thứ tự của các super class chính là thứ tự khi tìm kiếm
</code></pre>

<p>Trong <strong>old-style</strong> class, thứ tự của các superclass là depth-first, left-to-right
theo thứ tự xuất hiện trong bases list</p>

<p>{% codeblock python.py %}</p>

<blockquote><blockquote><blockquote><p>class A:</p>

<pre><code>  def test(self): print "A"
</code></pre>

<p>class B(A):</p>

<pre><code>  def test(self): print "B"
</code></pre>

<p>class C(A)</p>

<pre><code>  def test(self): print "C"
</code></pre>

<p>class D(B, C): pass</p>

<h1>order of D.<strong>bases</strong> is (B, C) so D.test => B.test</h1>

<p>D().test()
"B"
class E(C, B): pass</p>

<h1>order of E.<strong>bases</strong> is (C, B) so E.test => C.test</h1>

<p>E().test()
"C"</p></blockquote></blockquote></blockquote>

<h1>so what if we make an class is inherited from D, E</h1>

<h1>note that, D and E are inherited from 2 class B, C with reverse order</h1>

<blockquote><blockquote><blockquote><p>class F(D, E): pass</p>

<h1>in old-style class, it does not matter, the searching method</h1>

<h1>only care about order of superclass in <strong>bases</strong></h1>

<h1>so now F.test => D.test => B.test</h1>

<p>F().test()
"B"</p></blockquote></blockquote></blockquote>

<h1>even if we make an class is inherited from A, D, E</h1>

<h1>it still works and test() method will be test() method of A</h1>

<blockquote><blockquote><blockquote><p>class G(A, D, E): pass
G().test()
"A"
{% endcodeblock %}</p></blockquote></blockquote></blockquote>

<p>Cách phân giải method của <strong>old-style</strong> khá đơn giản và dễ hiểu. Nhưng nếu chúng
ta áp dụng quy luật này, đôi khi chúng ta sẽ phạm phải sai lầm khi kế thừa.
Giả sử, một class G được kế thừa từ A, D và E, trong khi A là parent class của D và E.
Rõ ràng, một lỗi nên được Python ném ra trong trường hợp này để bảo về việc kế thừa vòng tròn như vậy</p>

<p><strong>new-stlye</strong> giải quyết vấn đề này. <strong>new-style</strong> sử dụng MRO (Method Resolution Order) được giới thiệu từ Python 2.3</p>

<p>{% codeblock python.py %}</p>

<p>def mro(cls):</p>

<pre><code>"""
Return ordering of superclass of cls
This ordering was used when we want to access class instance atrribute

`cls`: class type we want to resolve

@raise `TypeError` if cannot resolution superclass order
@return `list` of class
"""
bases_cls = cls.__bases__
mro_base_lists = [mro(base_cls) for base_cls in bases_cls]
mro_list = [cls]
while mro_base_lists:
    # find the good head
    # good head is head of a list which is not is tail of any list in mro_base_lists
    list_head = (x[0] for x in mro_base_lists)
    set_tails = set()
    for x in mro_base_lists:
        set_tails.update(x[1:])

    good_head = None
    for head in list_head:
        if head not in set_tails:
            good_head = head
            break

    # if cannot find good_head, raise TypeError
    if not good_head:
        raise TypeError
    else:
        # add to mro_list
        mro_list.append(good_head)

        # remove good_head in all list and add to mro_list
        for alist in mro_base_lists:
            try:
                alist.remove(good_head)
            except Exception:
                pass
        mro_base_lists = [x for x in mro_base_lists if x]
return mro_list
</code></pre>

<p>class A: pass
class B(A): pass
class C(A): pass
class D(B, C): pass
class E(C, B): pass
class F(D, E): pass</p>

<p>def test_mro():</p>

<pre><code>assert mro(A) == [A]
print "Test1 passed"

assert mro(B) == [B, A]
print "Test2 passed"

assert mro(C) == [C, A]
print "Test 3 passed"

assert mro(D) == [D, B, C, A]
print "Test 4 passed"

assert mro(E) == [E, C, B, A]
print "Test 5 passed"

try:
    mro(F)
except Exception as e:
    assert isinstance(e, TypeError)
    print "Test 6 passed"
</code></pre>

<p>test_mro()</p>

<p>{% endcodeblock %}</p>

<p>Ý tướng của MRO là sắp xếp các super class với điều kiện:</p>

<pre><code>+ Nếu B là cha của C, B luôn luôn đứng trước C trong list.
</code></pre>

<p>Với điều kiện đó, Python sẽ ném ra một lỗi nếu chúng ta cố gắng định nghĩa class
D kế thừa từ (B, C), E kế thừa từ (C, B) và F kế thừa từ (D, E)</p>

<p>Tham khảo
<a href="http://www.python.org/download/releases/2.3/mro/">explaination in python docs</a></p>
]]></content>
  </entry>
  
</feed>
